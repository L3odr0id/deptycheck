<!-- idris
module Explanation.Derivation.Design.DerivationTask

import Control.Applicative.Const

import Explanation.Derivation.Design

%language ElabReflection
-->

```{eval-rst}
.. role:: idris(code)
  :language: idris
  :class: highlight
```

(sect-derivation-task)=

# Derivation task

We call an information given to a request of a DepTyCheck library user for derivation of a generator a *derivation task*.
Technically this request is done through a call to [a macro function](ref-deriveGen) or to [an elaboration script](ref-deriveGenExpr).
This information is technically given through a type signature of the macro result type or an explicit parameter of the elaboration script.
But *semantically* this information contains the following:

- the target, i.e. type or type constructor for which a generator is derived;
- if the target is a type constructor, then for each of its type arguments,
  information of whether the value of it is given or should be generated;
- external subgenerators, i.e. set of derivation tasks whose generators can be looked at the generation-site
  if a value of specific type is needed.

Also, some additional candidates were considered, but were temporarily put to the [backlog](../tbd):

- support of additional (arbitrary) `auto`-parameters of generator function;
- list of external subgenerators (or derivation tasks for subgenerators) which are available at the derivation-site;
- various configuration options for tuning distribution and ways of combining subgenerators.

:::{note}
Besides stuff for a derivation task, derived type signature contains also a special `Fuel` argument.
This is done as a workaround of [a temporary design decision](sect-fuel-pattern-workaround) on `Gen` monad
to support derivation for potentially infinite data structures.
:::

There are some examples of derivation tasks and corresponding generator signatures.

:::{todo}
We definitely need more examples of particular derivation tasks and corresponding signatures here.

Examples should contain:

- trivial examples for non-recursive data type with no type arguments;
- examples for recursive data type with no type arguments, like `Nat`;
- examples for a data type with some non-dependent type arguments (i.e. when no type argument does not depend on another);
  all variants of "all given", "all generated", "some given, some generated" should be present;
- example for a data type with dependent type arguments.
:::

(params-of-type-type)=

## Parameters of type `Type`

We definitely may want to be able to derive generators for data types that are polymorphic over some other types.

These are two cases to consider: when such parameter is given to a generator and when such parameter is generated by it.

:::{todo}
We need some rather short name for "parameters of type `Type`"
:::

### Given parameter of type `Type`

Consider a simple example of deriving generator for type `List a` for any given type `a`.
If type parameter of type `Type` is not considered specially, we would try to derive generator with the following signature:

<!-- idris
namespace ListGen_NoATreatment {
-->
```idris
genList : Fuel -> (a : Type) -> Gen (List a)
```
<!-- idris
  }
-->

However, no valuable generator can be derived with this signature,
since it cannot produce any non-empty list because generator is polymorphic over type `a`
(hence, it does not know anything about this type's structure)
and at the same time was given no external way to produce values of this type.

:::{note}
There may exist some polymorphic types that do not have this problem.
Consider a trivial example, when the generated type actually does not use any *value* of the type it is parameterised on:

```idris
data TrivPar a = MkTriv1 | MkTriv2 Bool

genTrivPar : Fuel -> (a : Type) -> Gen (TrivPar a)
```

Less trivial example would be if the parameter of type `Type` is used, but only on the type level:

```idris
data TypLev a = TypLev1 | TypLev2 (a = a)

genTypLev : Fuel -> (a : Type) -> Gen (TypLev a)
```

In these cases meaningful generators *may* be derived without any additions.
:::

To be able to derive meaningful generators,
it was decided that any given parameter of type `Type` shall be followed by an according values generator.

:::{note}
This is a temporary design decision.
It feels like a reasonable compromise between expressiveness and implementation complexity.
This is also connected to a [problem](sect-cons-order) of influence of the external generators set to the derived generator's body.

Another reason why it is temporary is that
we assume that the given parameter of type `Type` is present in the generated type only in a *covariant position*,
thus possibly requiring a generator, not a co-generator.
This is another temporary design decision for the sake of implementation simplicity.

In the future we would like to relax these requirements,
i.e. to require generators for those parameters that a used as values in covariant positions
and to require co-generators for those that a used in *contravariant positions*.
As a result, we would like to not to require anything for parameters that are not used as values or in functions inside the generated type
(i.e. that are either not used at all, or used only at the type-level).
:::

This decision, signature of a derivable generator for lists would look like this:

<!-- idris
namespace ListGen_GenAGiven {
-->
```idris
genList : Fuel -> (a : Type) -> (Fuel -> Gen a) => Gen (List a)
```
<!-- idris
  }
-->

Like mentioned in the note above, we can get a mix of used and unused polymorphic external generators.
For example:

```idris
genConst : Fuel ->
           (a : Type) -> (Fuel -> Gen a) =>
           (b : Type) -> (Fuel -> Gen b) =>
           Gen (Const a b)
```

### Generated parameter of type `Type`

However, a parameter of type `Type` may be not only given, but generated too.
Continuing with the `List` example, we'd want something like this:

<!-- idris
namespace ListGen_NoATreatment {
-->
```idris
genAnyList : Fuel -> Gen (a : Type ** List a)
```
<!-- idris
  }
-->

Alas, this signature also suffers from the fact that no meaningful generator can be derived for it.

For this, we suppose to have an external *generator of generators*, i.e. a generator with signature `Fuel -> Gen (a : Type ** Gen a)`.
That is, derivable meaningful generator of lists with generated type parameter would have the following signature:

<!-- idris
namespace ListGen_GivenGenGen {
-->
```idris
genAnyList : Fuel -> (Fuel -> Gen (a : Type ** Gen a)) => Gen (a : Type ** List a)
```
<!-- idris
  }
-->

In the case of several generated parameters of type `Type`, a single *generator of generators* is used,
i.e. the following signature would be expected by the derivator for a type with two parameters of type `Type`:

```idris
genAnyConst : Fuel -> (Fuel -> Gen (a : Type ** Gen a)) => Gen (a ** b ** Const a b)
```

:::{note}
Note that the fact that we have a single external *generator of generators* being used for all generated parameters of type `Type`
is also a temporary design decision made to simplicity of initial implementation.
We would love to have some mechanism of tuning which type argument would have which external *generator of generators* in the future.
:::

Surely, one can mix given and generated parameters of type `Type`.
In this case, presence of generated parameters of type `Type` requires presence of external *generator of generators* in the signature,
when each given parameters of type `Type` requires its own generator of values of its type.
For example:

```idris
genSomeConst : Fuel ->
               (Fuel -> Gen (a : Type ** Gen a)) =>
               (a : Type) -> (Fuel -> Gen a) =>
               Gen (b ** Const a b)
```

## Parameters of higher-kinded types

Parameters of type `Type` are responsible for polymorphism over *concrete types*.
However, sometimes types are polymorphic over *higher-kinded types*.
In this case, we would have parameters of a function type which result type in their turn would be `Type`.

Consider a type `Any` for `List`s from the standard library:

```idris
data Any : (0 p : a -> Type) -> List a -> Type where
  Here  : {0 xs : List a} -> p x      -> Any p (x :: xs)
  There : {0 xs : List a} -> Any p xs -> Any p (x :: xs)
```

It is polymorphic over an arbitrary type-level predicate over a type `a`.
According to the rules for the parameters of type `Type`, we could write the following signature for a generator of this type:

<!-- idris
namespace ListAnyGen_NoExternalP {
-->
```idris
genAny : Fuel ->
         (a : Type) -> (Fuel -> Gen a) =>
         (p : a -> Type) ->
         (xs : List a) ->
         Gen (Any p xs)
```
<!-- idris
  }
-->

Consider alternative generator, which also generates the list.

<!-- idris
namespace ListAnyGen_NoExternalP {
-->
```idris
genSomeAny : Fuel ->
             (a : Type) -> (Fuel -> Gen a) =>
             (p : a -> Type) ->
             Gen (xs ** Any p xs)
```
<!-- idris
  }
-->

As you can see, the similar problem with the parameters of type `Type` is present:
no meaningful generators can be derived for these signatures.

We might ask ourselves "what additional (external) generators may be demanded to make those signatures to be feasible?".
Well, for the parameter `p : a -> Type` there are two variants:

- `a` is given: {idris}`Fuel -> (x : a) -> Gen (p x)` and
- `a` is generated: {idris}`Fuel -> (Fuel -> Gen a) => Gen (x : a ** p x)`.

:::{note}
Additional external generator for `a` is required because `a` is a `Type`
but still is a not a concrete type (i.e. a parameter in the outer scope).

Note that we would not require this if `p` was, of type e.g. `Nat -> Type`.
For this case, we could derive generator for `Nat` or could use external one from the outermost context (if present).
:::

It happens that for different derivation tasks we might need different variants for external generators for `p`.
We would like to have one with the given `a` when `xs` is given for `Any` and generated `a` when `xs` is generated:

<!-- idris
namespace ListAnyGen_ExternalP {
-->
```idris
genAny : Fuel ->
         (a : Type) -> (Fuel -> Gen a) =>
         (p : a -> Type) -> (Fuel -> (x : a) -> Gen (p x)) =>
         (xs : List a) ->
         Gen (Any p xs)

genSomeAny : Fuel ->
             (a : Type) -> (Fuel -> Gen a) =>
             (p : a -> Type) -> (Fuel -> (Fuel -> Gen a) => Gen (x : a ** p x)) =>
             Gen (xs ** Any p xs)
```
<!-- idris
  }
-->

This all requires different signatures for different demands which is not supported yet
(more on the problem why it is so, read [here](sect-cons-order)).
That is why parameters of a function type returning `Type` are not supported yet for derivation.

:::{note}
This decision is a temporary one.
We really want to support this, but we postpone this
for the sake of feasibility of the initial implementation supporting at least simplest kind of type polymorphism.
:::
